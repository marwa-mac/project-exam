<div class="container mx-auto p-4">
    <h1 class="text-2xl font-bold mb-4">Ajouter des questions</h1>
    
    <div id="questionsContainer" class="space-y-6">
      <!-- Les questions seront ajoutées ici dynamiquement -->
    </div>
  
    <div class="mt-6 space-x-4">
      <button id="addDirectQuestion" class="bg-blue-500 text-white px-4 py-2 rounded">
        Ajouter une question directe
      </button>
      <button id="addQCMQuestion" class="bg-green-500 text-white px-4 py-2 rounded">
        Ajouter un QCM
      </button>
      <button id="saveAllQuestions" class="bg-purple-500 text-white px-4 py-2 rounded">
        Enregistrer toutes les questions
      </button>
    </div>
  </div>
  
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);
    const examId = urlParams.get('exam_id');
    
    if (!examId) {
      alert('Exam ID is missing');
      window.location.href = '/exams';
      return;
    }
  
    let questions = [];
  
    // Ajouter une question directe
    document.getElementById('addDirectQuestion').addEventListener('click', () => {
      const questionId = Date.now();
      questions.push({
        id: questionId,
        type: 'direct',
        exam_id: examId,
        content: '',
        tolerance_rate: 0,
        duration: 60,
        score: 1,
        options: [{ answer_text: '' }]
      });
      
      renderQuestions();
    });
  
    // Ajouter un QCM
    document.getElementById('addQCMQuestion').addEventListener('click', () => {
      const questionId = Date.now();
      questions.push({
        id: questionId,
        type: 'qcm',
        exam_id: examId,
        content: '',
        duration: 60,
        score: 1,
        options: [
          { answer_text: '' },
          { answer_text: '' }
        ]
      });
      
      renderQuestions();
    });
  
    // Enregistrer toutes les questions
    document.getElementById('saveAllQuestions').addEventListener('click', async () => {
      try {
        const responses = await Promise.all(
          questions.map(question => 
            fetch('/api/questions', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                exam_id: question.exam_id,
                question_type: question.type,
                content: question.content,
                tolerance_rate: question.tolerance_rate,
                duration: question.duration,
                score: question.score,
                options: question.options
              }),
              credentials: 'include'
            })
          )
        );
  
        const results = await Promise.all(responses.map(res => res.json()));
        
        if (results.every(result => result.message === 'Question created successfully')) {
          alert('Toutes les questions ont été enregistrées avec succès!');
          window.location.href = `/exam-details?id=${examId}`;
        } else {
          alert('Certaines questions n\'ont pas pu être enregistrées');
        }
      } catch (error) {
        console.error('Error saving questions:', error);
        alert('Une erreur est survenue lors de l\'enregistrement');
      }
    });
  
    // Rendu des questions
    function renderQuestions() {
      const container = document.getElementById('questionsContainer');
      container.innerHTML = '';
  
      questions.forEach((question, qIndex) => {
        const questionDiv = document.createElement('div');
        questionDiv.className = 'border p-4 rounded-lg bg-white shadow';
        
        // En-tête de la question
        questionDiv.innerHTML = `
          <div class="flex justify-between items-center mb-4">
            <h3 class="font-semibold">Question ${qIndex + 1} (${question.type === 'direct' ? 'Directe' : 'QCM'})</h3>
            <button class="text-red-500 delete-question" data-id="${question.id}">Supprimer</button>
          </div>
          <div class="mb-4">
            <label class="block mb-2">Question:</label>
            <textarea class="w-full p-2 border rounded question-content" data-id="${question.id}"
              placeholder="Entrez votre question ici">${question.content}</textarea>
          </div>
          <div class="grid grid-cols-2 gap-4 mb-4">
            <div>
              <label class="block mb-2">Durée (secondes):</label>
              <input type="number" class="w-full p-2 border rounded question-duration" data-id="${question.id}"
                value="${question.duration}">
            </div>
            <div>
              <label class="block mb-2">Score:</label>
              <input type="number" class="w-full p-2 border rounded question-score" data-id="${question.id}"
                value="${question.score}">
            </div>
          </div>
        `;
  
        // Ajout du champ de tolérance pour les questions directes
        if (question.type === 'direct') {
          questionDiv.innerHTML += `
            <div class="mb-4">
              <label class="block mb-2">Taux de tolérance (%):</label>
              <input type="number" class="w-full p-2 border rounded question-tolerance" data-id="${question.id}"
                value="${question.tolerance_rate}" min="0" max="100">
            </div>
          `;
        }
  
        // Options de réponse
        const optionsDiv = document.createElement('div');
        optionsDiv.className = 'space-y-3 mb-4';
        optionsDiv.innerHTML = `<label class="block mb-2">${question.type === 'direct' ? 'Réponse correcte' : 'Options de réponse'}:</label>`;
  
        question.options.forEach((option, oIndex) => {
          const optionDiv = document.createElement('div');
          optionDiv.className = 'flex items-center';
          optionDiv.innerHTML = `
            <input type="${question.type === 'direct' ? 'text' : 'text'}" 
              class="flex-1 p-2 border rounded option-answer" 
              data-qid="${question.id}" data-oid="${oIndex}"
              value="${option.answer_text}" 
              placeholder="${question.type === 'direct' ? 'Entrez la réponse correcte' : 'Option ' + (oIndex + 1)}">
            ${question.type === 'qcm' ? `
              <button class="ml-2 text-red-500 delete-option" data-qid="${question.id}" data-oid="${oIndex}">
                Supprimer
              </button>
            ` : ''}
          `;
          optionsDiv.appendChild(optionDiv);
        });
  
        // Bouton pour ajouter une option (QCM seulement)
        if (question.type === 'qcm') {
          optionsDiv.innerHTML += `
            <button class="mt-2 text-blue-500 add-option" data-qid="${question.id}">
              + Ajouter une option
            </button>
          `;
        }
  
        questionDiv.appendChild(optionsDiv);
        container.appendChild(questionDiv);
      });
  
      // Gestion des événements
      document.querySelectorAll('.question-content').forEach(el => {
        el.addEventListener('input', (e) => {
          const questionId = parseInt(e.target.dataset.id);
          const question = questions.find(q => q.id === questionId);
          if (question) question.content = e.target.value;
        });
      });
  
      document.querySelectorAll('.question-duration').forEach(el => {
        el.addEventListener('input', (e) => {
          const questionId = parseInt(e.target.dataset.id);
          const question = questions.find(q => q.id === questionId);
          if (question) question.duration = parseInt(e.target.value) || 0;
        });
      });
  
      document.querySelectorAll('.question-score').forEach(el => {
        el.addEventListener('input', (e) => {
          const questionId = parseInt(e.target.dataset.id);
          const question = questions.find(q => q.id === questionId);
          if (question) question.score = parseInt(e.target.value) || 0;
        });
      });
  
      document.querySelectorAll('.question-tolerance').forEach(el => {
        el.addEventListener('input', (e) => {
          const questionId = parseInt(e.target.dataset.id);
          const question = questions.find(q => q.id === questionId);
          if (question) question.tolerance_rate = parseInt(e.target.value) || 0;
        });
      });
  
      document.querySelectorAll('.option-answer').forEach(el => {
        el.addEventListener('input', (e) => {
          const questionId = parseInt(e.target.dataset.qid);
          const optionIndex = parseInt(e.target.dataset.oid);
          const question = questions.find(q => q.id === questionId);
          if (question) question.options[optionIndex].answer_text = e.target.value;
        });
      });
  
      document.querySelectorAll('.delete-question').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const questionId = parseInt(e.target.dataset.id);
          questions = questions.filter(q => q.id !== questionId);
          renderQuestions();
        });
      });
  
      document.querySelectorAll('.delete-option').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const questionId = parseInt(e.target.dataset.qid);
          const optionIndex = parseInt(e.target.dataset.oid);
          const question = questions.find(q => q.id === questionId);
          
          if (question && question.options.length > 2) {
            question.options.splice(optionIndex, 1);
            renderQuestions();
          } else {
            alert('Un QCM doit avoir au moins 2 options');
          }
        });
      });
  
      document.querySelectorAll('.add-option').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const questionId = parseInt(e.target.dataset.qid);
          const question = questions.find(q => q.id === questionId);
          
          if (question) {
            question.options.push({ answer_text: '' });
            renderQuestions();
          }
        });
      });
    }
  });
  </script>